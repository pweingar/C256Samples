
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass --long-address --flat -b -D FILETYPE=0 --m65816 --intel-hex -o vdma.hex --list=vdma.lst --labels=vdma.lbl src\vdma.s
; Tue Nov 03 21:23:54 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					FILETYPE=0

;******  Processing input file: src\vdma.s


;******  Processing file: src\kernel.s

=$001018				FK_PUTC             = $001018 ; Print a character to the currently selected channel
=$001084				FK_LOCATE           = $001084 ; Reposition the cursor to row Y column X
=$0010a8				FK_CLRSCREEN        = $0010A8 ; Clear the screen
=$00112c				FK_SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.

;******  Return to file: src\vdma.s


;******  Processing file: src\vicky_ii_def.s

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				VKY_RESERVED_00         = $AF0002
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		      = $AF1F80
=$af2000				GRPH_LUT0_PTR		        = $AF2000
=$af2400				GRPH_LUT1_PTR		        = $AF2400
=$af2800				GRPH_LUT2_PTR		        = $AF2800
=$af2c00				GRPH_LUT3_PTR		        = $AF2C00
=$af3000				GRPH_LUT4_PTR		        = $AF3000
=$af3400				GRPH_LUT5_PTR		        = $AF3400
=$af3800				GRPH_LUT6_PTR		        = $AF3800
=$af3c00				GRPH_LUT7_PTR		        = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		      = $AF4000
=$af4100				GAMMA_G_LUT_PTR		      = $AF4100
=$af4200				GAMMA_R_LUT_PTR		      = $AF4200
=$af5000				TILE_MAP0       		    = $AF5000     ;$AF5000 - $AF57FF
=$af5800				TILE_MAP1               = $AF5800     ;$AF5800 - $AF5FFF
=$af6000				TILE_MAP2               = $AF6000     ;$AF6000 - $AF67FF
=$af6800				TILE_MAP3               = $AF6800     ;$AF6800 - $AF6FFF
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$af8800				FONT_MEMORY_BANK1       = $AF8800     ;$AF8800 - $AF8FFF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000
=$afe000				BTX_START               = $AFE000     ; BEATRIX Registers
=$afffff				BTX_END                 = $AFFFFF

;******  Processing file: src\VKYII_CFP9553_BITMAP_def.s

=$af0100				BM0_CONTROL_REG     = $AF0100
=$af0101				BM0_START_ADDY_L    = $AF0101
=$af0102				BM0_START_ADDY_M    = $AF0102
=$af0103				BM0_START_ADDY_H    = $AF0103
=$af0104				BM0_X_OFFSET        = $AF0104
=$af0105				BM0_Y_OFFSET        = $AF0105
=$af0106				BM0_PRIORITY        = $AF0106
=$af0107				BM0_RESERVED_7      = $AF0107
=$af0108				BM1_CONTROL_REG     = $AF0108
=$af0109				BM1_START_ADDY_L    = $AF0109
=$af010a				BM1_START_ADDY_M    = $AF010A
=$af010b				BM1_START_ADDY_H    = $AF010B
=$af010c				BM1_X_OFFSET        = $AF010C
=$af010d				BM1_Y_OFFSET        = $AF010D
=$af010e				BM1_PRIORITY        = $AF010E
=$af010f				BM1_RESERVED_7      = $AF010F

;******  Return to file: src\vicky_ii_def.s


;******  Processing file: src\VKYII_CFP9553_VDMA_def.s

=$af0400				VDMA_CONTROL_REG        = $AF0400
=$01					VDMA_CTRL_Enable        = $01
=$02					VDMA_CTRL_1D_2D         = $02       ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					VDMA_CTRL_TRF_Fill      = $04       ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					VDMA_CTRL_Int_Enable    = $08       ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					VDMA_CTRL_SysRAM_Src    = $10       ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					VDMA_CTRL_SysRAM_Dst    = $20       ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$80					VDMA_CTRL_Start_TRF     = $80       ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$00					VDMA_XFER_VRAM2VRAM = $00           ; VRAM -> VRAM transfer
=$10					VDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					VDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$af0401				VDMA_BYTE_2_WRITE       = $AF0401   ; Write Only - Byte to Write in the Fill Function
=$af0401				VDMA_STATUS_REG         = $AF0401   ; Read only
=$01					VDMA_STAT_Size_Err      = $01       ; If Set to 1, Overall Size is Invalid
=$02					VDMA_STAT_Dst_Add_Err   = $02       ; If Set to 1, Destination Address Invalid
=$04					VDMA_STAT_Src_Add_Err   = $04       ; If Set to 1, Source Address Invalid
=$80					VDMA_STAT_VDMA_IPS      = $80       ; If Set to 1, VDMA Transfer in Progress (this Inhibit CPU Access to Mem)
=$af0402				VDMA_SRC_ADDY_L         = $AF0402   ; Pointer to the Source of the Data to be stransfered
=$af0403				VDMA_SRC_ADDY_M         = $AF0403   ; This needs to be within Vicky's Range ($00_0000 - $3F_0000)
=$af0404				VDMA_SRC_ADDY_H         = $AF0404
=$af0405				VDMA_DST_ADDY_L         = $AF0405   ; Destination Pointer within Vicky's video memory Range
=$af0406				VDMA_DST_ADDY_M         = $AF0406   ; ($00_0000 - $3F_0000)
=$af0407				VDMA_DST_ADDY_H         = $AF0407
=$af0408				VDMA_SIZE_L             = $AF0408   ; Maximum Value: $40:0000 (4Megs)
=$af0409				VDMA_SIZE_M             = $AF0409
=$af040a				VDMA_SIZE_H             = $AF040A
=$af040b				VDMA_IGNORED            = $AF040B
=$af0408				VDMA_X_SIZE_L           = $AF0408   ; Maximum Value: 65535
=$af0409				VDMA_X_SIZE_H           = $AF0409
=$af040a				VDMA_Y_SIZE_L           = $AF040A   ; Maximum Value: 65535
=$af040b				VDMA_Y_SIZE_H           = $AF040B
=$af040c				VDMA_SRC_STRIDE_L       = $AF040C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040d				VDMA_SRC_STRIDE_H       = $AF040D   ;
=$af040e				VDMA_DST_STRIDE_L       = $AF040E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040f				VDMA_DST_STRIDE_H       = $AF040F   ;

;******  Return to file: src\vicky_ii_def.s


;******  Processing file: src\VKYII_CFP9553_SDMA_def.s

=$af0420				SDMA_CTRL_REG0           = $AF0420
=$01					SDMA_CTRL0_Enable        = $01
=$02					SDMA_CTRL0_1D_2D         = $02     ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					SDMA_CTRL0_TRF_Fill      = $04     ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					SDMA_CTRL0_Int_Enable    = $08     ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					SDMA_CTRL0_SysRAM_Src    = $10     ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					SDMA_CTRL0_SysRAM_Dst    = $20     ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$00					SDMA_XFER_SRAM2SRAM = $00           ; SRAM -> SRAM transfer
=$10					SDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					SDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$30					SDMA_XFER_SRAMIO = $30              ; SRAM <-> IO transfer (see: SDMA_CONTROL_REG1 for config and direction)
=$40					SDMA_CTLR0_RSVD          = $40      ; Reserved
=$80					SDMA_CTRL0_Start_TRF     = $80      ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$af0421				SDMA_CTRL_REG1           = $AF0421  ; Write Only - Byte to Write in the Fill Function
=$01					SDMA_CTRL1_IO_Src		 = $01		; 1 = Source is an IO Address (ADC, SuperIO, IDE)
=$02					SDMA_CTRL1_IO_Src16		 = $02		; 0 = Src 8Bits Transfer / 1= 16Bits Transfer
=$04					SDMA_CTRL1_IO_Dst		 = $04		; 1 = Destination is an IO Address (DAC, SuperIO, IDE)
=$08					SDMA_CTRL1_IO_Dst16      = $08      ; 0 = Dst 8bits Transfer / 1= 16bits
=$af0422				SDMA_SRC_ADDY_L         = $AF0422   ; Pointer to the Source of the Data to be stransfered
=$af0423				SDMA_SRC_ADDY_M         = $AF0423   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0424				SDMA_SRC_ADDY_H         = $AF0424
=$af0425				SDMA_DST_ADDY_L         = $AF0425   ; Destination Pointer within CPU's video memory Range
=$af0426				SDMA_DST_ADDY_M         = $AF0426   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0427				SDMA_DST_ADDY_H         = $AF0427
=$af0428				SDMA_SIZE_L             = $AF0428   ; Maximum Value: $40:0000 (4Megs)
=$af0429				SDMA_SIZE_M             = $AF0429
=$af042a				SDMA_SIZE_H             = $AF042A
=$af042b				SDMA_IGNORED            = $AF042B
=$af0428				SDMA_X_SIZE_L           = $AF0428   ; Maximum Value: 65535
=$af0429				SDMA_X_SIZE_H           = $AF0429
=$af042a				SDMA_Y_SIZE_L           = $AF042A   ; Maximum Value: 65535
=$af042b				SDMA_Y_SIZE_H           = $AF042B
=$af042c				SDMA_SRC_STRIDE_L       = $AF042C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042d				SDMA_SRC_STRIDE_H       = $AF042D   ;
=$af042e				SDMA_DST_STRIDE_L       = $AF042E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042f				SDMA_DST_STRIDE_H       = $AF042F   ;
=$af0430				SDMA_BYTE_2_WRITE       = $AF0430   ; Write Only - Byte to Write in the Fill Function
=$af0430				SDMA_STATUS_REG         = $AF0430   ; Read only
=$01					SDMA_STAT_Size_Err       = $01      ; If Set to 1, Overall Size is Invalid
=$02					SDMA_STAT_Dst_Add_Err    = $02      ; If Set to 1, Destination Address Invalid
=$04					SDMA_STAT_Src_Add_Err    = $04      ; If Set to 1, Source Address Invalid
=$08					SDMA_STAT_TimeOut_Err    = $08      ; will be set to 1 if a Timeout occur when transfering between data from and to VRAM

;******  Return to file: src\vicky_ii_def.s


;******  Return to file: src\vdma.s


;******  Processing file: src\macros.s


;******  Return to file: src\vdma.s


;******  Processing file: src\page_00_inc.s

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$000008				OPL2_ADDY_PTR_LO = $000008  ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000108				DIVIDER_0        = $000108 ;0 Byte  Unsigned divider
=$000108				D0_OPERAND_A     = $000108 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$00010a				D0_OPERAND_B     = $00010A ;2 Bytes Divider 0 Divisor ex B in A/B
=$00010c				D0_RESULT        = $00010C ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$00010e				D0_REMAINDER     = $00010E ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000110				DIVIDER_1        = $000110 ;0 Byte  Signed divider
=$000110				D1_OPERAND_A     = $000110 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$000112				D1_OPERAND_B     = $000112 ;2 Bytes Divider 1 Divisor ex B in A/B
=$000114				D1_RESULT        = $000114 ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D1_REMAINDER     = $000116 ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_SIGNED_32  = $000120 ; The 32 Bit Adders takes 12Byte that are NOT RAM Location
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: src\vdma.s

=0					F_HEX = 0                                   ; FILETYPE value for a HEX file to run through the debug port
=1					F_PGX = 1                                   ; FILETYPE value for a PGX file to run from storage
=$b00000				VRAM = $B00000                              ; Base address for video RAM
>fffc	00 30				HRESET          .word <>START               ; Bootstrapping vector
=$002000				GLOBALS = *
>2000					SOURCE          .dword ?                    ; A pointer to copy from
>2004					DEST            .dword ?                    ; A pointer to copy to
>2008					SIZE            .dword ?                    ; The number of bytes to copy
.3000	18		clc		START           CLC
.3001	fb		xce		                XCE
.3002	08		php		            PHP
.3003	e2 20		sep #$20	            SEP #$20
.3005	48		pha		            PHA
.3006	a9 00		lda #$00	            LDA #0
.3008	48		pha		            PHA
.3009	ab		plb		            PLB
.300a	68		pla		            PLA
.300b	28		plp		            PLP
.300c	08		php		            PHP
.300d	c2 20		rep #$20	            REP #$20
.300f	48		pha		            PHA
.3010	a9 00 20	lda #$2000	            LDA #GLOBALS
.3013	5b		tcd		            TCD
.3014	68		pla		            PLA
.3015	28		plp		            PLP
.3016	c2 30		rep #$30	            REP #$30
.3018	a9 0c 00	lda #$000c	                LDA #Mstr_Ctrl_Graph_Mode_En | Mstr_Ctrl_Bitmap_En ; Mstr_Ctrl_Text_Mode_En | Mstr_Ctrl_Text_Overlay
.301b	8f 00 00 af	sta $af0000	                STA @l MASTER_CTRL_REG_L
.301f	e2 20		sep #$20	            SEP #$20
.3021	a9 00		lda #$00	                LDA #0
.3023	8f 04 00 af	sta $af0004	                STA @l BORDER_CTRL_REG      ; Turn off the border
.3027	8f 00 07 af	sta $af0700	                STA @l MOUSE_PTR_CTRL_REG_L ; And turn off the mouse pointer
.302b	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES             ; Recalculate the screen size information
.302f	a9 03		lda #$03	                LDA #%00000011
.3031	8f 00 01 af	sta $af0100	                STA @l BM0_CONTROL_REG
.3035	e2 20		sep #$20	            SEP #$20
.3037	a9 00		lda #$00	            LDA #<0
.3039	8f 01 01 af	sta $af0101	            STA BM0_START_ADDY_L
.303d	a9 00		lda #$00	            LDA #>0
.303f	8f 02 01 af	sta $af0102	            STA BM0_START_ADDY_L+1
.3043	a9 00		lda #$00	            LDA #`0
.3045	8f 03 01 af	sta $af0103	            STA BM0_START_ADDY_L+2
.3049	a9 00		lda #$00	                LDA #0                      ; Set the bitmap scrolling offset to (0, 0)
.304b	8f 04 01 af	sta $af0104	                STA @l BM0_X_OFFSET
.304f	8f 05 01 af	sta $af0105	                STA @l BM0_Y_OFFSET
.3053	20 73 30	jsr $3073	                JSR INITLUT                 ; Initiliaze the LUT
.3056	20 b0 30	jsr $30b0	                JSR CLR_BITMAP              ; Zero out the bitmap
.3059	f4 20 00	pea #$0020	                PEA #32                     ; X
.305c	f4 20 00	pea #$0020	                PEA #32                     ; Y
.305f	f4 90 01	pea #$0190	                PEA #400                    ; Width
.3062	f4 c8 00	pea #$00c8	                PEA #200                    ; Height
.3065	20 fe 30	jsr $30fe	                JSR NESTRECT                ; nestrect(x, y, width, height)
.3068	c2 20		rep #$20	            REP #$20
.306a	3b		tsc		                TSC
.306b	18		clc		                CLC
.306c	69 0a 00	adc #$000a	                ADC #5*2
.306f	1b		tcs		                TCS
.3070	ea		nop		lock            NOP
.3071	80 fd		bra $3070	                BRA lock
.3073					INITLUT
.3073	08		php		                PHP
.3074	0b		phd		                PHD
.3075					locals
>0001					L_COLOR1        .byte ?
>0002					L_COLOR0        .byte ?
.3075	e2 20		sep #$20	            SEP #$20
.3077	a9 ff		lda #$ff	                LDA #255                ; color0 := 255
.3079	48		pha		                PHA
.307a	a9 00		lda #$00	                LDA #0                  ; color1 := 0
.307c	48		pha		                PHA
.307d	c2 30		rep #$30	            REP #$30
.307f	3b		tsc		                TSC
.3080	5b		tcd		                TCD
.3081	e2 20		sep #$20	            SEP #$20
.3083	a2 04 00	ldx #$0004	                LDX #4
.3086	a0 ff 00	ldy #$00ff	                LDY #255
.3089	a5 02		lda $2002	loop            LDA L_COLOR0
.308b	9f 00 24 af	sta $af2400,x	                STA @l GRPH_LUT1_PTR,X
.308f	e8		inx		                INX
.3090	a9 40		lda #$40	                LDA #64
.3092	9f 00 24 af	sta $af2400,x	                STA @l GRPH_LUT1_PTR,X
.3096	e8		inx		                INX
.3097	a5 01		lda $2001	                LDA L_COLOR1
.3099	9f 00 24 af	sta $af2400,x	                STA @l GRPH_LUT1_PTR,X
.309d	e8		inx		                INX
.309e	e8		inx		                INX
.309f	c6 02		dec $2002	                DEC L_COLOR0
.30a1	c6 02		dec $2002	                DEC L_COLOR0
.30a3	e6 01		inc $2001	                INC L_COLOR1
.30a5	e6 01		inc $2001	                INC L_COLOR1
.30a7	88		dey		                DEY
.30a8	d0 df		bne $3089	                BNE loop
.30aa	c2 20		rep #$20	            REP #$20
.30ac	68		pla		                PLA
.30ad	2b		pld		                PLD
.30ae	28		plp		                PLP
.30af	60		rts		                RTS
.30b0					CLR_BITMAP
.30b0	08		php		                PHP
.30b1	e2 20		sep #$20	            SEP #$20
.30b3	a9 05		lda #$05	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill
.30b5	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG     ; Set to 1D fill
.30b9	a9 00		lda #$00	                LDA #0
.30bb	8f 01 04 af	sta $af0401	                STA @l VDMA_BYTE_2_WRITE    ; Set the byte to fill with
.30bf	a9 00		lda #$00	                LDA #0                      ; Set the VDMA destination address
.30c1	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.30c5	8f 06 04 af	sta $af0406	                STA @l VDMA_DST_ADDY_M
.30c9	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H
.30cd	a9 00		lda #$00	                LDA #<(640*480)             ; Set the number of bytes to write
.30cf	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.30d3	a9 b0		lda #$b0	                LDA #>(640*480)
.30d5	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_M
.30d9	a9 04		lda #$04	                LDA #`(640*480)
.30db	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.30df	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG     ; Trigger the transfer
.30e3	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF
.30e5	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.30e9	ea		nop		                NOP
.30ea	ea		nop		                NOP
.30eb	ea		nop		                NOP
.30ec	af 01 04 af	lda $af0401	wait            LDA @l VDMA_STATUS_REG      ; Wait for the transfer to complete
.30f0	29 80		and #$80	                AND #VDMA_STAT_VDMA_IPS
.30f2	c9 80		cmp #$80	                CMP #VDMA_STAT_VDMA_IPS
.30f4	f0 f6		beq $30ec	                BEQ wait
.30f6	a9 00		lda #$00	                LDA #0
.30f8	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG     ; Clear the control bits
.30fc	28		plp		                PLP
.30fd	60		rts		                RTS
.30fe					NESTRECT
.30fe	08		php		                PHP
.30ff	0b		phd		                PHD
.3100					locals
>0001					L_COLOR         .word ?
>0003					L_DP            .word ?
>0005					L_STATUS        .byte ?
>0006					L_RETURNPC      .word ?
>0008					P_HEIGHT        .word ?
>000a					P_WIDTH         .word ?
>000c					P_Y             .word ?
>000e					P_X             .word ?
.3100	c2 30		rep #$30	            REP #$30
.3102	f4 01 00	pea #$0001	                PEA #1                      ; Set initial color
.3105	3b		tsc		                TSC
.3106	5b		tcd		                TCD
.3107	a5 0e		lda $200e	draw_rect       LDA P_X
.3109	48		pha		                PHA
.310a	a5 0c		lda $200c	                LDA P_Y
.310c	48		pha		                PHA
.310d	a5 0a		lda $200a	                LDA P_WIDTH
.310f	48		pha		                PHA
.3110	a5 08		lda $2008	                LDA P_HEIGHT
.3112	48		pha		                PHA
.3113	a5 01		lda $2001	                LDA L_COLOR
.3115	48		pha		                PHA
.3116	20 44 31	jsr $3144	                JSR FILLRECT                ; fillrect(x, y, width, height, color)
.3119	3b		tsc		                TSC                         ; Remove the parameters from the stack
.311a	18		clc		                CLC
.311b	69 0a 00	adc #$000a	                ADC #5*2
.311e	1b		tcs		                TCS
.311f	e6 01		inc $2001	                INC L_COLOR                 ; if (++color > 255) return
.3121	a5 01		lda $2001	                LDA L_COLOR
.3123	c9 00 01	cmp #$0100	                CMP #256
.3126	b0 16		bcs $313e	                BGE done
.3128	c6 0a		dec $200a	                DEC P_WIDTH                 ; if (--width == 0) return
.312a	c6 0a		dec $200a	                DEC P_WIDTH
.312c	f0 10		beq $313e	                BEQ done
.312e	30 0e		bmi $313e	                BMI done
.3130	c6 08		dec $2008	                DEC P_HEIGHT                ; if (--height == 0) return
.3132	c6 08		dec $2008	                DEC P_HEIGHT
.3134	f0 08		beq $313e	                BEQ done
.3136	30 06		bmi $313e	                BMI done
.3138	e6 0e		inc $200e	                INC P_X                     ; x++
.313a	e6 0c		inc $200c	                INC P_Y                     ; y++
.313c	80 c9		bra $3107	                BRA draw_rect               ; And draw this new rectangle
.313e					done
.313e	c2 20		rep #$20	            REP #$20
.3140	68		pla		                PLA                         ; Remove the local from the stack
.3141	2b		pld		                PLD
.3142	28		plp		                PLP
.3143	60		rts		                RTS
.3144					FILLRECT
.3144	08		php		                PHP
.3145	0b		phd		                PHD
.3146					locals
>0001					L_DP            .word ?
>0003					L_STATUS        .byte ?
>0004					L_RETURNPC      .word ?
>0006					P_COLOR         .word ?         ; The color to draw
>0008					P_HEIGHT        .word ?         ; The height of the rectangle to draw
>000a					P_WIDTH         .word ?         ; The width of the rectangle to draw
>000c					P_Y             .word ?         ; The Y coordinate of the upper left corner
>000e					P_X             .word ?         ; The X coordinate of the upper left corner
.3146	e2 20		sep #$20	            SEP #$20
.3148	a9 07		lda #$07	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_1D_2D
.314a	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG     ; Set to 2D fill
.314e	a3 06		lda $06,s	                LDA P_COLOR
.3150	8f 01 04 af	sta $af0401	                STA @l VDMA_BYTE_2_WRITE    ; Set the byte to fill with
.3154	c2 20		rep #$20	            REP #$20
.3156	a3 0c		lda $0c,s	                LDA P_Y
.3158	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.315c	a9 80 02	lda #$0280	                LDA #640
.315f	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.3163	18		clc		                CLC
.3164	a3 0e		lda $0e,s	                LDA P_X
.3166	6f 04 01 00	adc $000104	                ADC @l M0_RESULT
.316a	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.316e	e2 20		sep #$20	            SEP #$20
.3170	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.3174	69 00		adc #$00	                ADC #0
.3176	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H
.317a	c2 20		rep #$20	            REP #$20
.317c	a3 0a		lda $0a,s	                LDA P_WIDTH                 ; Set the width and height
.317e	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.3182	a3 08		lda $08,s	                LDA P_HEIGHT
.3184	8f 0a 04 af	sta $af040a	                STA @L VDMA_Y_SIZE_L
.3188	a9 80 02	lda #$0280	                LDA #640                    ; Set the destination stride
.318b	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L
.318f	e2 20		sep #$20	            SEP #$20
.3191	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG     ; Trigger the transfer
.3195	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF
.3197	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.319b	ea		nop		                NOP
.319c	ea		nop		                NOP
.319d	ea		nop		                NOP
.319e	af 01 04 af	lda $af0401	wait            LDA @l VDMA_STATUS_REG      ; Wait for the transfer to complete
.31a2	29 80		and #$80	                AND #VDMA_STAT_VDMA_IPS
.31a4	c9 80		cmp #$80	                CMP #VDMA_STAT_VDMA_IPS
.31a6	f0 f6		beq $319e	                BEQ wait
.31a8	a9 00		lda #$00	                LDA #0
.31aa	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG     ; Clear the control bits
.31ae	2b		pld		                PLD
.31af	28		plp		                PLP
.31b0	60		rts		                RTS

;******  End of listing
